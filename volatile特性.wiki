= volatile特性 =

== Java内存模型 ==
1.jvm虚拟机p364 8种操作
2.java内存模型规定执行上述8种操作的规则：8条，
  其中第二条：不允许一个线程丢弃它的最近的assign操作，即变量在工作内存中改变了之后必须把该变化同步到主内存。

== volatile特性 ==
=== 1.保证此变量对所有线程的可见性 ===
=== 2.禁止指令重排序优化 ===

volatile指令把修改同步到内存时，意味着所有之前的操作都已经执行完成。
理解如下：
因为volatile指令执行之后，如果之前的操作未同步到内存，又因为assigin操作不可以被丢弃，所以它必定在之后某时刻执行。违背了volatile的”禁止指令重排序“的原则。
所以，volatile指令执行之后，之前的操作一定同步到了主内存。并且，在其他线程执行时，必定从主内存中同步到了工作内存。因为”执行“完成意味着其他线程cpu的实际执行，而实际执行是将共享变量从主内存中copy到工作内存中，再执行。

== 内存屏障是禁止指令重排序的实现方式 ==
对应汇编代码中的lock
