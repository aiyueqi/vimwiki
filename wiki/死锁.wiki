= 死锁 =
== 资源:需要排他性使用的对象 ==
=== 可抢占资源 ===
可以从拥有它的进程中抢占，不会产生任何副作用。eg 存储器
=== 不可抢占资源 ===
不引起相关的计算失败的情况下，无法把它从占有它的进程处抢占过来。eg CD刻录机

死锁和不可抢占资源有关，因为可抢占资源的潜在死锁通常可以通过在进程之间重新分配资源而化解

== 死锁概述 ==
=== 死锁定义 ===
如果一个进程集合中的每个进程都在等待只能由该进程集合中的其他进程才能引发的事件，那么该进程集合就是死锁的

== 资源死锁 ==
每个进程所等待的事件是释放该进程集合中其他进程所占有的资源。最常见。

== 资源死锁的条件 ==
1.互斥条件：每个资源要么已经分配给了一个进程，要么就是可用的
2.占有和等待条件：已经得到了某个资源的进程可以再请求新的资源
3.不可抢占条件：已经分配给一个进程的资源不能强制性地被抢占，它只能被占有它的进程显式释放
4.环路等待条件：死锁发生时，系统中一定有由两个或以上的进程组成的一条环路，该环路中的每个进程都在等待着下一个进程所占有的资源

上述四个条件同时发生，才会发生死锁。

== 处理死锁的策略 ==
1.忽略该问题 — 鸵鸟算法
2.检测死锁并恢复
3.仔细对资源进行分配，动态避免死锁
4.通过破坏引起死锁的四个必要条件之一，防止死锁

== 死锁检测 ==
=== 每种类型一个资源的死锁检测 ===
DFS，检查图是否有环。有环即死锁
=== 每种类型多个资源的死锁检测 ===
使用资源向量矩阵 p250

== 从死锁中恢复 ==
=== 利用抢占恢复 ===
临时将某个资源从当前所有者转移到另一个进程
=== 利用回滚恢复 ===
周期性对进程进行检查点检查，即将进程的状态写入一个文件以备以后重启。
=== 通过杀死进程恢复 ===

== 死锁避免 ==
=== 银行家算法 ===
知道线程当前占有的资源数量，及其对资源的最大需求，判断对请求的满足是否会导致进入不安全状态。（即如果所有进程突然请求对资源的最大需求，程序一定会死锁）但缺乏实用价值，因为最大值很难预测，而且进程数不固定，资源也可能突然不可用

== 死锁预防 ==
死锁从本质上不可避免， 因为它需要获知未来的请求，而这些请求是不可知的。

| 条件       | 处理方式             |
|------------|----------------------|
| 互斥       | 一切都使用假脱机技术 |
| 占有和等待 | 在开始就请求全部资源 |
| 不可抢占   | 抢占资源             |
| 环路等待   | 对资源按序编号       |

死锁预防方法汇总

== 其他问题 ==
=== 两阶段加锁 ===
应用在数据库系统，第一阶段对所有所需的记录加锁，第二阶段更新记录

=== 通信死锁 ===
如网络通信，信息丢失，进程阻塞。可以设置超时时间避免

=== 活锁 ===
某些情况下，使用轮询（忙等待）进入临界区（互斥的时间很短，挂起等待的开销很大的情况），进程没有被阻塞，但总是一再消耗完分配给他们的cpu

=== 饥饿 ===
资源分配策略，导致某些进程无限制地推后，尽管它没有被阻塞
